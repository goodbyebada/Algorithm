## 📌 문제 설명

https://school.programmers.co.kr/learn/courses/30/lessons/42577?language=javascript

### 💡 접근 방법

### 왜 막혔는가/ 왜 틀렸는가

- [ ] 구현 실수
- [x] 아이디어 자체를 못 떠올림
- [ ] 유형 파악 실패
- [ ] 유형은 알았는데 적용 방법을 몰랐음
- [ ] 전형적인 테크닉(전처리, DP 점화식 등)을 몰라서 막힘
- [ ] 시간 복잡도 추정/최적화 미흡

#### 이유:

1. 문자열의 길이 순으로 오름차순
   -> 0번 인덱스 ~ (1 - N-1) 비교
   -> 1번 인덱스 ~ (2 - N-1) 비교
   N + N-1 + ... + 1 => O(N^2) => 시간 초과

### ✨ 해결 방법

- 핵심 아이디어:

1. set 이용하기 O(N\*M)

   - 번호의길이는 <= 20이다.
   - 한 번호당, set를 이용해 할 수 있다.

2. sort 후, 앞과 비교 하기 O(NlogN)
   - 문자열 sort -> 접두어 비슷한 것 순으로 정렬된다. + 길이
     - 정렬 O(NlogN)
   - i+1번째 단어가 i번 단어로 시작하는지 판단한다.

- 재발 방지 훈련:

  0.  패턴 인식
      "어떤 문자열이 다른 문자열의 접두어인지"
      "문자열들 사이의 포함 관계"
      "모든 쌍을 비교해야 하는 문자열 문제"

  1.  포함하느냐?를 따진다면 set를 생각해보자.
  2.  모든 쌍 비교 -> 정렬 후 인접 비교
  3.  접두어/ 접미어 -> 정렬 문제

      - 정렬하면 관련된 문자열들이 인접하게 배치됨

  4.  set을 이용한 부분 문자열 문제

- 참고 자료:

### 왜 이 방법이 맞는지 설명하기

### 같은 유형 반복하기

- [ ] 문제1
- [ ] 문제2

### 🚨 초보적이거나 오래 걸린 디버깅

### 📌 정리
