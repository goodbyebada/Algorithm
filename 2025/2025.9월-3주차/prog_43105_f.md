## 📌 문제 설명

https://school.programmers.co.kr/learn/courses/30/lessons/43105

### 💡 접근 방법

- DP
- 아이디어는 어렵지 않았으나, 구현하는데 시간이 오래 걸려 f 처리했다.

### 왜 막혔는가/ 왜 틀렸는가

- [x] 구현 실수
- [ ] 아이디어 자체를 못 떠올림
- [ ] 유형 파악 실패
- [ ] 유형은 알았는데 적용 방법을 몰랐음
- [ ] 전형적인 테크닉(전처리, DP 점화식 등)을 몰라서 막힘
- [ ] 시간 복잡도 추정/최적화 미흡

#### 이유:

**1. 처음 시도 방법**:

- 일차원 배열로 만들려고 함. 이진 탐색과 같은 줄 알고 위에서부터 2\*i+1, 2\*i+2로 접근함 -> 이진 탐색이랑 다름!!
  => 이차원 배열로 하는게 훨씬 쉬움. 대각선 아래 [row+1][col] [row+1][col+1]이다.

**2.2차원 배열 만들면서 실수**:

- 2차원 배열일때 조심하자. triangle[i] 도 일차원 배열 , 즉 참조이기 때문에 원본 배열 triangle이 값이 바뀌는 이슈가 있었다

```js
//     dp 초기화
for (let i = 0; i < triangle.length; i++) {
  dp.push(triangle[i]);
  // => dp.push([...triangle[i]]);
}
```

**3. 시간 초과**:

- 같은 로직이지만, map vs forloop+ push 차이로 시간초과 통과 불통이 결정났다. 정확한 이유는 모르지만 벤치마킹 결과 map 항상 빠르다. 이차원 배열 초기화 시에는 map을 사용하자.

```js
const dp = triangle.map((row) => [...row]); // 깊은 복사
```

### ✨ 해결 방법

- 핵심 아이디어:

  - 1.  TopDown
  - 2. BottomUp
    - 아래에서부터 위로 올라간다.
  - [row+1][j] [row+1][j+1] 중 더 큰 놈을 [row][j] 에 더한다.

- 재발 방지 훈련:
- 참고 자료:

### 왜 이 방법이 맞는지 설명하기

### 같은 유형 반복하기

- [ ] 문제1
- [ ] 문제2

### 🚨 초보적이거나 오래 걸린 디버깅

### 📌 정리
