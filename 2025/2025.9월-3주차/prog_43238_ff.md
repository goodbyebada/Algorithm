## 📌 문제 설명

[입국심사](https://school.programmers.co.kr/learn/courses/30/lessons/43238)

### 💡 접근 방법

- pq

### 왜 막혔는가/ 왜 틀렸는가

- [ ] 구현 실수
- [ ] 아이디어 자체를 못 떠올림
- [ ] 유형 파악 실패
- [ ] 유형은 알았는데 적용 방법을 몰랐음
- [ ] 전형적인 테크닉(전처리, DP 점화식 등)을 몰라서 막힘
- [ ] 시간 복잡도 추정/최적화 미흡

#### 이유:

**생각한 방법**:

- pq를 이용한다.
- 10^10으로 순회하초면 1초 초과함 + 빨리 끝나는 곳 pq로 알 수 있음

- 문제)

  - 1. 한 지점이(빨리) 끝나는 순간 비교하게 됨.

    - 현재 끝난 지점 vs (대기시간 + 더 빨리 끝나는 지점)를 해야함
    - 더 빨리 끝나는 지점 < 현재 끝난 지점(끝나는 시간)을 리스트업해야함
    - 더 빨리 끝나는 지점별 대기 시간을 골라야함

**잘못 생각한 지점**:

1.10^10이 times가 아니라, 사람들 수 였다.
=> 따라서 내가 한 방법은 pq.pop을 10^10번 하는 방법이기 때문에 시간 초과다.

### ✨ 해결 방법

- 핵심 아이디어:

  - `최소 시간` `이분 탐색`

  - 10^10개로 이분 탐색 말고는 시간안에 수행하기에 방법이 없다..!
    - start 시간 = 0
    - end 시간 = Max 시간 \* n
    - `SUM((현재 시간)/(한 명당 가능한 시간))` -> 이 시간대에 처리할 수 있는 모든 사람의 양
    - SUM >= n -> 그럼 mid 포인터 기준 오른쪽을 날리고, 왼쪽을 본다. logN
    - SUM < n -> 왼쪽 볼 필요 없다. 오른쪽만 본다. logN
    - => 절반 날림! 시간 안에 탐색 가능

- 재발 방지 훈련:
- 참고 자료:

### 왜 이 방법이 맞는지 설명하기

### 같은 유형 반복하기

- [ ] 문제1
- [ ] 문제2

### 🚨 초보적이거나 오래 걸린 디버깅

1. sum === n 일때 바로 return 하도록 했다가 틀림
   => sum === n을 만족하는 더 작은 시간(mid)이 있을 수 있기 때문에, 저장해두고 계속 탐색 ㄱㄱ
2. end start 설정 잘못 놨었음

```js
// 무한 루프 발생
if (sum > n) {
  end = mid; // mid-1이 아님!
} else {
  start = mid; // mid+1이 아님!
}
```

```
start = 10, end = 11
mid = Math.floor((10 + 11) / 2) = 10

sum < n인 경우:
start = mid = 10  // start가 그대로!
end = 11          // end도 그대로!
// 다음 루프에서 또 mid = 10... 무한루프!
```

1.

```js
while (start < end) {
  // <= 대신
  if (sum >= n) {
    end = mid; // mid 그대로
  } else {
    start = mid + 1; // mid+1
  }
}
```

2.

```js
while (start <= end) {
  // <= 유지
  if (sum >= n) {
    answer = mid; // 답 저장
    end = mid - 1; // mid-1
  } else {
    start = mid + 1; // mid+1
  }
}
```

### 📌 정리
