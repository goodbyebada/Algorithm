## 📌 문제 설명

https://school.programmers.co.kr/learn/courses/30/lessons/42895

### 💡 접근 방법

- 행렬로 접근 했다 면봉 ~ !
- DP 유형인 걸 알았음에도 못 풀었군..

### 왜 막혔는가/ 왜 틀렸는가

- [ ] 구현 실수
- [x] 아이디어 자체를 못 떠올림
- [ ] 유형 파악 실패
- [ ] 유형은 알았는데 적용 방법을 몰랐음
- [x] 전형적인 테크닉(전처리, DP 점화식 등)을 몰라서 막힘
- [ ] 시간 복잡도 추정/최적화 미흡

#### 이유:

- DP 유형임이 명시되어있어 DP임은 알았다..
- N을 이용한 조합 & 캐시가 필요하다고 생각함
- 행과 열 5, 55, 555, 5555으로 구성하고 각 행(사칙 연산)열 캐시하면 되나?
  문제 1) 삼차원 배열..? 사칙연산까지 해야하니까 + 중복이 너무 생김 -> `set 사용~~`
  문제 2) 각 조합끼리 또 조합을 만들어야 된다. 캐시의 의미가 있나? -> `작은 문제 조합해서 큰 문제 풀어야함으로 이어졌어야함`

      	ex) 5 \* 55 + 5\* 555 되는가?

  문제 3) 어떻게 쪼개서 조합을 만들것인가..? -> `이전 개수 (사칙 연산) 이전 개수 , 점화식`

### ✨ 해결 방법

- 핵심 아이디어:

> dp[i] = N을 i개 사용해서 만들 수 있는 모든 수들의 집합

- `"N과 사칙연산만 사용해서 표현할 수 있는 방법 중 N 사용횟수의 최솟값"`

      - N이 1개일때부터 해본다. -> 안되면 2개일때, 3개일때...

  - 2개 => 사칙연산 없는 2개, 1개(사칙 연산)1개
  - 3개 => 개수가 3개가 되어야함 -> 사칙연산 없는 3개 + 1개(사칙연산)2개, 2개(사칙연산)1개
  - 4개 => 개수가 4개가 되어야함 ->사칙연산 없는 4개 + 1개(사칙연산)3개, 2개(사칙연산)2개, ...
  - 각 단계에서 target 확인하면 됨

  > 점화식 : dp[i] = 모든 dp[j] ⊕ dp[i-j] 조합 + N을 i번 연결한 수

- 사용 횟수별로 만들 수 있는 모든 수를 만들어야한다.

- 재발 방지 훈련:

  - 문제 패턴:

    1.  작은 단위로 큰 것을 만든다.
    2.  이전 결과를 재 사용해야한다.
    3.  모든 경우를 확인해야한다 => DP+완전탐색

  - 점화식 세우기:

    1.  "dp[i] = ?"를 명확히 하기
    2.  dp[i]는 어떤 dp[j]들로 만들어지는가?"
    3.  dp[1] =?
    4.  언제 답을 찾았다고 할 것인가?

- 참고 자료:

### 왜 이 방법이 맞는지 설명하기

### 같은 유형 반복하기

- [ ] 문제1
- [ ] 문제2

### 🚨 초보적이거나 오래 걸린 디버깅

1.repeat는 string일 때만 가능. -> 전환 후 Number Type 변환 필요

2. set => for of 문법 적용 가능

3. 무조건 j와 i-j로 이뤄진 조합이 답이 나올 거라 생각해 loop안에 넣었다 틀렸다.

4. 풀이 보고 `N을 i번 연결한 수`을 놓쳤다..

### 📌 정리
