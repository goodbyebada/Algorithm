## 📌 문제 설명

https://www.acmicpc.net/problem/1504

### 💡 접근 방법

### 왜 막혔는가/ 왜 틀렸는가

- [ ] 구현 실수
- [x] 아이디어 자체를 못 떠올림
- [ ] 유형 파악 실패
- [ ] 유형은 알았는데 적용 방법을 몰랐음
- [ ] 전형적인 테크닉(전처리, DP 점화식 등)을 몰라서 막힘
- [ ] 시간 복잡도 추정/최적화 미흡

#### 이유

- **문제 잘못 해석함**

> 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.

1번에서 N번 정점으로 가는 경로에서 v1과 v2를 거쳐야한다. 그렇지 않으면 방문할 수 없는 경로이다.
근데 1 -> N -> v1 -> v2 -> N 도 포함된다고 생각했다.

### ✨ 해결 방법

- 핵심 아이디어:
  1.  1 -> v1 -> v2 -> N
  2.  1 -> v2 -> v1 -> N
      두 가지의 경로만 생각하면 된다. 다익스트라를 이용해 출발점이 각각 1, v1, v2 일때 다익스트라를 이용하면 쉽게 해결된다!
- 재발 방지 훈련:
- 참고 자료:

- 시간 단축:
  1. 처음에 {vertex, dist} Object와 인접리스트를 이용해 풀이했다. 896ms 시간이 나왔다. minHeap => O(ElogN)의 시간인데, E = 200,000 N ≤ 800 이었다.
  2. N\*N 배열로 수정했다. 또한 graph 갱신 시 가장 작은 E(간선)만 기록했다. 648ms
  3. {vertex, dist} 노드 관리를 리스트로 수정했다. => 444ms

### 왜 이 방법이 맞는지 설명하기

### 같은 유형 반복하기

- [ ] 문제1
- [ ] 문제2

### 🚨 초보적이고 오래 걸린 디버깅

1.  // 1-> v2 -> v1 -> N
    //🚨 틀린 부분 v1 -> N이기 때문에 dist1 써야함. 배열 잘못 씀..
    ````js
    const d2 = dist0[v2] + dist2[v1] + dist1[N];```
    ````
2.  siftDown에서 swap 안함

### 📌 정리
