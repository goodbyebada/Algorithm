## 📌 문제 설명

https://www.acmicpc.net/problem/17835

### 💡 접근 방법

- 다익스트라

### 왜 막혔는가/ 왜 틀렸는가

- [x] 구현 실수
- [ ] 아이디어 자체를 못 떠올림
- [ ] 유형 파악 실패
- [ ] 유형은 알았는데 적용 방법을 몰랐음
- [ ] 전형적인 테크닉(전처리, DP 점화식 등)을 몰라서 막힘
- [ ] 시간 복잡도 추정/최적화 미흡

#### 이유:

0. 도착점에서 역으로 출발하는 것이기 때문에, 방향을 모두 역방향으로 해야함!!

1. 인접행렬로 접근함 ~ 메모리 초과

   - 인접행렬 N^2 => 10^10 (N=10^5)
   - 인접리스트 E (간선의 길이) (E = 5 \* 10^6)
     - 인접리스트를 N\*E로 착각함 아님 공간 E개 생기는 것임

2. start 노드를 같이 다익스트라로 처리하면 오류가 생기지 않을까??

   - ✨ 같은 dist를 공유해도 상관이 없다!
     dist는 최단거리 값만 기록하는 것이기 때문에 값이 섞이지 않는다. 최단거리 + graph 거리 와 비교해 갱신하는 것이니까 -> dist[i] + d로 헷갈려서 생긴 착각

   - ✨ 한번에 다익스트라 로직을 수행해도 된다.
     굳이 따로 한번씩 실행할 필요없다. 시작점만 0으로 둔다면, k1 에서 출발했을때의 거리 vs k2에서 출발했을 때거리 비교해 자동 최솟값 갱신 되기 때문

3. 따라서 각각 ds 돌릴 필요없다. 단일 다익스트라로 가능함

### ✨ 해결 방법

- 핵심 아이디어:
- 재발 방지 훈련:
- 참고 자료:

### 왜 이 방법이 맞는지 설명하기

### 같은 유형 반복하기

- [ ] 문제1
- [ ] 문제2

### 🚨 초보적이고 오래 걸린 디버깅

1. MinHeap 작성할때 this.arr[i][0] 으로 잘 적었는지 확인할 것 -> this[i][0]으로 오타남
2. 대소 관계 작성할때 주의할 것
3. siftDown 할때 l, r 잘 들어갔는지 주의할 것, 복사하다가 같은 숫자를 참조하고, l을 두번 사용한다거나 실수 발생했었음

### 📌 정리
