# 📌 문제 설명

[문제 링크](https://www.acmicpc.net/problem/1194)

## 💡 접근 방법

bfs와 비트 마스킹을 사용하는 문제였다.

## ✨ 해결 방법

1. 최단 시간을 위해 방문한 곳은 중복 방문하지 말아야한다.
2. 하지만 `열쇠`가 없이 방문했던 곳은, `열쇠`를 획득했을 시 방문이 가능하다.
3. 따라서 `열쇠`가 있을때와 없을때 방문처리를 개별로 해줘야한다.
4. visited[nx][by][6(열쇠의 종류)]로 하면 문제가 생긴다.
   - 열쇠를 여러개 가지고 있을 수 있기 때문이다. 하나로만 하면, 여러개의 열쇠를 얻어 여러 문을 통과할 수 있음에도 불구하고, 한 문만 여는 경우로만 계산이 되어 틀린답이 된다.
     => 때문에 `비트마스킹`을 사용해야한다.
5. "a"를 기준으로 fedcba 순서로 열쇠 획득을 표시한다.
   ex) `열쇠` a 획득시 1 << 0 ( === 000001)
   ex) `열쇠` b 획득시 1 << 1 ( === 000010) =>
   ex) `열쇠` a와 b 둘 다 획득했다면 | 을 이용해야한다. 1 << 0 | 1 <<1 (000011)

6. `문`을 마주쳤을때, `문`에 대응 되는 `열쇠`가 있음을 확인해야한다.
   => & 연산자를 통해 확인한다.
7. 이러한 분기처리를 이용해 bfs 방문을 한다. 1을 만날때마다 최소값임을 비교해 갱신한다.
8. 대문자 소문자는 `charCodeAt을` 이용해 구분할 수 있다.

### 문제

### 🚨 초보적인 디버깅

1. 문자와 숫자가 섞여있는 board여서 숫자도 str type이었다. 평소 숫자로 이뤄진 문제에 익숙해서 `"1" + dir[0]` 으로 새로운 좌표를 계산해 문제가 생겼다.
   -> board[nx][ny] 검사하는데 문제 생김
2. ` isKey(char)``isDoor(char) `매개변수 네이밍은 char, 매개변수에 들어가는 값은 val이다. 네이밍을 다르게 했더니, 코드가 길어지고 로직이 복잡해지니까 char 대신 val을 넣는걸 잊었다. 한번 더 디버깅 해야했다.

### 📌 정리

1. 여러개의 상태를 관리해야한다. + 동시에 가지고 있는 상태를 관리해야한다! => 비트마스킹을 이용하자
2. 대소문자 구분은 charCodeAt을 이용할 수 있다
3. 문자로 주어지는 map일때, "1"과 1 type 구분 조심하자.
4. BFS는 후진 없이 앞만 보고 직진하기 때문에 먼저 만나는 놈이 최단 거리이다!
