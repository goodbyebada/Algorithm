# 📌 문제 설명

## 💡 접근 방법

- 처음 틀린 방법

0. 완전 잘못 생각한 것 => 이진 트리 != 완전 이진 트리 **문제를 잘 읽자**
1. 재귀를 이용해 풀이했다 (애초에 틀리긴 했지만 ) -> 시간 초과
   JS 콜 스택은 약 1만개라고 한다. 현재 n은 10만개
2. 새 그래프를 만들어 DFS(재귀)로 답을 출력하려고 했다.
3. 그래프를 만들 떄 오른쪽 트리부터 만들었다. -> 아직 뭐가 틀리고 뭐가 맞았는지는 못 찾았지만, 확실한 건 시간이 오래걸린다!

- 알게 된 방법

0. 방문하면서 root를 출력하면 시간을 그래프를 안 만들어도 된다.
1. `index`를 이용해 root -> 왼쪽 트리 -> 오른쪽 트리를 유지하자.

   - inorder list에서 rootIndex를 기준으로 left tree, right tree를 구분할 수 있다.

   - `left tree의 길이`로 `left tree postOrderlist`를 구할 수 있다.
     => leftTreeEndIndex : postStartOrder + left tree 노드 개수 -1

   - 이를 이용해 `right tree postOrderList`를 구할 수 있다.

2. 이전 방법에서 `postOrderIndex`를 따로 전역으로 관리했는데, 이렇게 각 트리의 postOrder 범위를 안다면 끝 인덱스를 이용해 접근해 편리하다.

3. N이 최대 10만이기 때문에 반복문을 이용해 작성해야한다.

## ✨ 해결 방법

0. (left)(root)(right)
1. (left)(right)(root)

- [inStart, inEnd, postStart,postEnd]로 관리한다.
- 처음은 [0, N-1, 0 , N-1]로 초기화한다.
- rootNode 는 postOrder[postEnd]이다. answer에 넣는다.
- right Tree, left Tree 정보를 스택에 넣는다.
  = left Tree 우선 방문을 위해 순서를 유지한다.

- ✨ rootNode -> inOrder의 [0,rootNodeIndex-1] 는 leftTree임을 알게 되었다.
  따라서 현재 leftTree의 postOrder 범위도 알 수 있다!
  => [0, 0+ leftTree 노드의 개수 -1]
  즉, 현재 leftTree의 rootNode는 postOrder[0+leftTree 노드의 개수-1]임을 쉽게 구할 수 있다.
  ~ rightTree도 마찬가지이다.

leftTree의 Inorder => [inStart,rootNodeIndex-1]
leftTree 노드의 개수 => `(rootNodeIndex-1) - inStart +1`
leftTree의 postOrder => [postStart, postStart+ (rootNodeIndex-1) - inStart]

rightTree의 Inorder => [rootNodeIndex+1,inEnd]
leftTree의 postOrder => [postStart+ (rootNodeIndex-1) - inStart, postEnd-1]

- 🚨 방문하면 안되는 경우
  - postStart > postEnd || inStart > inEnd

### 📌 정리

- post 배열에서 rootNode를 찾고, 또 inOrder 배열에서 rootNode index를 찾고, post index도 전역으로 관리하면서 헷갈렸었는데
  rootNode는 바로 출력하고, postOrder inOrder을 분리해 start, end index만 관리하니까 명쾌했다.
