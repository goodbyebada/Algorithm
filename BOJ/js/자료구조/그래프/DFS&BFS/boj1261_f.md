## 📌 문제 설명

https://www.acmicpc.net/problem/1261

### 💡 접근 방법

### 왜 막혔는가/ 왜 틀렸는가

- [x] 구현 실수
- [ ] 아이디어 자체를 못 떠올림
- [x] 유형 파악 실패
- [ ] 유형은 알았는데 적용 방법을 몰랐음
- [ ] 전형적인 테크닉(전처리, DP 점화식 등)을 몰라서 막힘
- [ ] 시간 복잡도 추정/최적화 미흡

#### 이유:

- 한번 방문시 visited를 벽 여부와 상관없이 true 했다.

  - 한번 방문하면 다시는 방문하지 않음으로 처리
  - 문제: 나중에 다른 경로에서 벽을 더 적게 부수고 오는 경우를 반영 못함
  - BFS+최소 벽 부수기 문제는 벽을 부순 횟수 기준으로 최소값을 저장해야 함

- 일반 BFS로 처리했다.

### ✨ 해결 방법

- 핵심 아이디어:

  - 한번 방문시 visited를 벽 여부와 상관없이 true 했다.

    - 나중에 다른 경로에서 벽을 더 적게 부수고 오는 경우를 잡지 못한다.
    - BFS+ 최소 벽 부수기 문제는 , 벽 부순 횟수 기준으로 최솟값을 저장해야한다.
      따라서! `cnt 기준 방문 최소값`을 써야한다.

    - visited[mx][my] > cnt 확인해 최솟값이라면 큐에 넣는다.

  - 0-1 BFS

    - 0이면 앞쪽에 넣고, 1이면 뒤에 넣는다.
    - 우선순위 큐 없이도, 최소 벽 부순 횟수를 보장
    - <-> 일반 BFS는 최단경로 보장.
      빈칸 먼저 가는 경로보다, 벽 부순 횟수가 적은 다른 경로 방문하는 것이 우선이기 때문에

- 재발 방지 훈련:

  1.  BFS + 가중치 문제에서는 항상 방문 체크 기준이 무엇인지 먼저 확인

      - 벽을 덜 부술 수록 우선순위가 높음

  2.  비용이 0/1이면 0-1 BFS, 일반 가중치면 다익스트라를 생각

- 참고 자료:

### 왜 이 방법이 맞는지 설명하기

### 같은 유형 반복하기

- [ ] 문제1
- [ ] 문제2

### 🚨 초보적이거나 오래 걸린 디버깅

- ‼️ 입력 잘 확인해라. ""인지 " "인지 !
- ‼️ 머리로 알 것 같아도 로직 써놓고 코드짜자 , 코드 짜다가 조건 다 놓침
- ‼️ x, y <-> r, w 인지 확정하고 문제 풀 것
  - 파라미터에 의존하는 방법도 있음. 하지만 애초에 배열을 만들어야하기 때문에 정의를 잘 해놓을 것

### 📌 정리
