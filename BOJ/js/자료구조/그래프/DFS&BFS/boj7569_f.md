## 📌 문제 설명

https://www.acmicpc.net/problem/7569

골드5

### 💡 접근 방법

- bfs

### 왜 막혔는가/ 왜 틀렸는가

- [ ] 구현 실수
- [ ] 아이디어 자체를 못 떠올림
- [ ] 유형 파악 실패
- [ ] 유형은 알았는데 적용 방법을 몰랐음
- [ ] 전형적인 테크닉(전처리, DP 점화식 등)을 몰라서 막힘
- [ ] 시간 복잡도 추정/최적화 미흡

- [x] 국어 이슈, M N H 입력형식 잘못 파악해 삽질함 🤬

#### 이유:

- 1. 도마도 전염이 상하좌우앞뒤 각각 1일씩 걸리는 것으로 파악 => 추후 한꺼번에 1일이 걸리는 level 개념으로 수정
- 2. 그래도 답이 안나옴 -> M N H 잘못 파악해 수정
- 3. `분기 처리 요상함`
  - 모두 익은 상태, 익을 수 없는 상태
  - 모두 익은 상태 => O(M*N*H) 3중 for문으로 0이 없고, 1이 들어간 좌표가 > 0 일때 0 return
  - bfs 모두 방문 후, O(M*N*H) 3중 for문으로 0 유무 확인

### ✨ 해결 방법

- 핵심 아이디어: BFS
- 재발 방지 훈련:
  - BFS일때 방문 구역 각각 1일 걸리는 것인지, 한꺼번에 1일 걸리는 것인지 조건 확인할 것
  - M N H 그림으로 한번 그리고 보기. 맞는 것 같은데, 답 안나온다 싶으면 재점검할 것
- 참고 자료:

#### 복잡한 분기처리

- 안 익은 토마토를 처음부터 세어준다.

(이미 토마토가 익어있는 상황 출력)

- 안익은 토마토가 0개라면 0 출력

(모두 익지 못하는 상황 출력)

- 큐에 넣을 때 (큐에 들어가는 토마토는 안 익은 토마토) 안 익은 토마토의 값을 뺀다.
- bfs 를 처리하고 난후 안익은 토마토가 > 0 라면 -1 출력

### 왜 이 방법이 맞는지 설명하기

1. 왜 DFS가 아닌가?
   - DFS는 깊게 들어가기 때문에, 다른 경로에서 더 빨리 익을 수 있는 경우를 반영하지 못함
   - DFS는 깊게 들어가면서 가능한 모든 선택지를 확인해야할 때 유리하다. => 모든 배치 확인 (전체 탐색, 백트래킹)
2. 왜 BFS인가?
   - 시작점에서 거리 순으로 확장하기 때문에 먼저 도달한 토마토 경로가 바로 최소 일수임을 의미함
   - 큐에 넣을 때 한번만 방문하면 더 늦게 도달하는 경로는 이미 익은 상태이므로 반영할 필요 없음
   - 때문에 최단 경로를 보장한다.
   - (최단거리, 최소거리, 레밸별 단계 처리)

### 같은 유형 반복하기

- [ ] 문제1
- [ ] 문제2

### 🚨 초보적이고 오래 걸린 디버깅

### 📌 정리
