# 📌 문제 설명

[문제](https://www.acmicpc.net/problem/17836)

## 💡 접근 방법

### 첫번째 접근 방법

- 공주님이 있는 곳으로 가는 방법은 BFS를 이용해야한다.
- 칼 있는 상태로 접근하기, 없는 상태로 접근하기 두 가지가 있다.
- 칼이 있을 수도 없을수도 있기 때문에, 없는 상태로 BFS하는 로직을 작성해 이동할 때마다 count++을 한다.
- 칼을 BFS 방법으로 찾는다.
- 만약 칼이 존재한다면,칼 까지 가는 길을 count++ 하고, 칼이 있는 좌표에서 공주님이 있는 좌표까지 count++을 해 초를 세어준다.
- 두 가지의 count 케이스 중 가장 작은 것을 답으로 도출한다.

따라서

- 공주님을 찾는 일반 BFS
- 칼을 찾기 위한 BFS
- (칼을 찾고 난 후) 벽이 없는 상태에서 공주님에게 접근한다.
  -> 칼을 찾고 난 후에도 BFS를 사용하려니까 굉장히 복잡했다. 하지만 아래 내용을 적용하면 쉽게 접근할 수 있다.
  `칼은 벽을 다 찢고 갈 수 있기 때문에 굳이 BFS를 사용할 필요없다.|칼의 위치 - 공주님의 위치|가 최단 거리이다.`
  ### boj17836_f1.js 참고!

#### 이해 안 가는 점

Q. BFS가 왜 최단 거리를 찾기 위한 알고리즘일까?
특히 초를 count 할때, pop할때 count한다고 가정하면, 한 경로가 아니라, 다른 경로를 방문할때도 count++해서 초가 잘못 세어지는 거 아닌가?

A. BFS는 가까운 곳부터 차례대로 방문한다. 따라서, 처음 도달한 거리가 최단 거리가 된다. BFS는 `여러 경로를 동시에 확장해 나가는 알고리즘`임을 잊지말자!

Q. 특히 초를 count 할때, pop할때 count한다고 가정하면, 한 경로가 아니라, 다른 경로를 방문할때도 count++해서 초가 잘못 세어지는 거 아닌가?

Ex) [1,0], [0,1] 이렇게 들어있다면 최단 거리는 [1,0]으로 이동한 후 [1,0]의 상하좌우 [1,1] [2,0] 이 큐에 들어가 -> 예를 들어 최단거리인 경로가 [1,0] [2,0] 이 루트라고 가정하자면, [1,0] [2,0] 이 두가지 좌표만 방문할 때 count를 ++ 해야하는데 [1,0]과 완전 다른 경로인 [0,1]도 count++을 해주잖아

A. 당연함! 경로가 다르다! 때문에 예시와 같이 전역으로 count를 더하는 것이 아니라, 큐에 함께 저장해줘야한다.
예시를 들어 설명하자면

- 큐 :[1,0], [0,1] - count 1
- 큐 : [0,1] | [1,1] [2,0] -> count 2
  하지만 예시와 같이 전역적으로 count를 세어준다면 [2,0]은 count 3이 된다. 틀림!

# 🚨 주의할 점

**계속 틀렸던 곳 반례**

- BFS를 다 돌아도 장애물로 인해 N,M을 방문하지 못하는 경우가 있다.
- BFS 함수로 답만 return하고 싶다면, time과 gramTime이 T보다 작은지 확인해야한다.

## ✨ 해결 방법

### 두번째 접근 방법

- 1.  gram이 있을 때와 없을 때를 비교해야한다.
- 2.  BFS를 통해 공주님이 있는 최단 거리를 찾는다.
- 3.  BFS를 통해 탐색하는 중 gram을 찾는다면, ✨ gram이 있을 시 시간 :gram까지 오는 거리 + |gram위치.x - N| + |gram의 위치.y - M| -> 벽을 뚫고 직진할 수 있기 때문에 최단거리임!
- 4.  gram이 없다면 (N,M)을 찾을 때까지 방문하면 된다.

- T시간 이내 접근할 수 있다면, Math.min(gram 시간, 방문 시간)
- T시간 이내 구출할 수 없다면 Fail 출력

### boj17836_f2.js 참고!

### 📌 정리

1. 벽을 뚫고 바로 갈 수 있다면 최단 거리는 gram까지 오는 거리 + |gram위치.x - N| + |gram의 위치.y - M|
2. 장애물이 있다면 BFS를 돌아도, 목표지점에 도달하지 못하는 경우가 있을 수 있다. (목표지점을 장애물들이 가로 막고 있다면) **문제 주의**
3. 방문한 곳을 1(장애물)로 표시하면 visited 배열을 쓰지 않을 수 있다.
4. 처음에 gram이 있는 곳은 큐에 넣지 않았다. => 하지만 넣어야한다. 다음 방문할 좌표의 길이가 길어질 수 있다. (gram이 없다고 가정하기 때문에 돌아간다.)
   -> 최단 거리가 될 수 있음에도 돌아가기 때문에 틀림
5. 매번 헷갈리는 index++, index 반환한 뒤 ++ 해준다!! 그만 헷갈리자!
6. 좌표를 방문함과 동시에 `visited` 표시를 해야 중복 방문을 하지 않는다. 큐에서 pop 시 `visited` 처리 했더니 `메모리 초과`를 겪었다.
