# 📌 문제 설명

[Gold V] 수 고르기 - 2230
[문제 링크](https://www.acmicpc.net/problem/2230)

## 💡 접근 방법

- 최소 힙을 이용해 접근할 수 있습니다.

## ✨ 해결 방법

1. 비교를 위해 오름차순으로 정렬합니다.
2. 각 반의 리스트의 다음에 접근할수록 값이 커지기 때문에, 최솟값을 키워서 (최대-최소)의 최솟값을 구할 수 있습니다.
3. N개의 반에서 한명씩 나와야하기 때문에, N반의 최솟값을 최소 힙에 넣어줍니다.

- 최소값을 구하기 위해 일반 정렬 대신 , 최소 힙을 사용해야합니다. 일반 정렬의 시간 복잡도는 `N*M*logM*N`로 `시간초과` 발생합니다. , 최소 힙으로 구현한다면 `N*M logN`

4. 최소힙의 pop() 하면 최솟값이 나옵니다. 해당 좌표의 다음 좌표로 이동해 새로운 값을 넣어줍니다. -> 자동 정렬이 됩니다. 그리고 현재 max보다 크다면 max의 값을 갱신 한 후, 최소 힙의 현재 최솟값에 접근해 (최대-최소)의 값을 업데이트합니다.
5. N개의 대표 값이 나와야하기 때문에 최솟값은 pop되어야합니다. 그리고 같은 행의 다음 열이 힙에 들어가야합니다. 왜냐면 N개의 반이 나와야하기 때문에 N명이 유지되어야하기 때문입니다.
6. 만약 열이 M-1이라면 더 이상 넣을 값이 없기 때문에 N보다 작아집니다. 이는 조건에 맞지 않기 때문에 while문에서 탈출합니다.

# 틀렸던 이유

- Minheap을 구하는데 굉장히 오랜 시간이 걸렸습니다.. 자잘한 실수가 많았는데
- bubbleUp시 1일때 예외처리해줘야한다.
- 또한 0부터 시작이라면 Math.floor((idx - 1) / 2)이다. 처음에 Math.floor((idx) / 2)로 시작해 idx의 부모가 1인 참사가 났었다.
- bubbleUp시 현재 idx에 parent의 값으로 업데이트 하고, 맨 마지막에 idx에 curr 값을 한번만 붙여넣으면 계속 복사하지 않아도 된다.
- pop시 0과 1일때 예외처리해야한다.

- bubbleDown 시 left, right index가 있는지 확인하면 undefined 접근을 방지할 수 있다.
