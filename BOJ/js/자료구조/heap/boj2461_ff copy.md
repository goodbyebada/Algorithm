# 📌 문제 설명

[Gold II] 대표 선수 - 2461
[문제 링크](https://www.acmicpc.net/problem/2461)

---

## 💡 접근 방법

- 각 반에서 한 명씩 골라 `(가장 큰 수 - 가장 작은 수)`의 최솟값을 구하는 문제.
- 모든 반에서 골라야 하므로, **N개의 값이 항상 유지**되어야 함.
- 이 문제는 **최소 힙(MinHeap)** 을 사용해 효율적으로 풀 수 있다.

---

## ✨ 해결 방법

1. **입력값을 오름차순 정렬**한다. → 각 반 별로.
2. 첫 번째 열(가장 작은 수)만 힙에 넣는다.
   - 최소 힙에는 항상 N개의 값이 유지된다 (각 반에서 한 명씩).
3. `max`는 현재 힙 안에서 가장 큰 값, `min`은 힙의 루트 값.
   - 처음엔 첫 열의 값들로 초기화한다.
4. 힙에서 가장 작은 값을 꺼내고,
   - 그 값의 **다음 열의 값**을 다시 힙에 넣는다.
   - 이때 `max`를 갱신할 수 있다면 갱신한다.
5. `answer = max - min`을 계속 갱신하며 **최솟값**을 추적한다.
6. 만약 꺼낸 값이 **해당 반의 마지막 학생이라면**, 더 이상 값을 채울 수 없으므로 반복을 종료한다.

---

## ✅ 시간 복잡도 비교

| 방법        | 시간 복잡도             |           |
| ----------- | ----------------------- | --------- |
| 일반 정렬   | `O(N * M * log(M * N))` | 시간 초과 |
| **MinHeap** | `O(N * M * log N)`      |

---

## ❌ 틀렸던 이유

- `MinHeap` 구현 시 자잘한 실수 발생:
  - `bubbleUp()`에서 `length === 1` 예외처리 필요.
  - 인덱스가 `0부터 시작`이므로 부모 인덱스는 `Math.floor((i - 1) / 2)`.
  - 최종적으로 `curr`을 `this.heap[idx]`에 넣어주는 방식으로 복사 최소화.
- `pop()` 시 `length === 0` 또는 `1`일 때 예외처리 누락.
- `bubbleDown()` 시 자식 노드 접근 전 **index 존재 여부 확인** 필수.
