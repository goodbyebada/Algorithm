# 실수 정리 🥲

1. dp 배열 갱신할 때 `[prevX][prevX]`로 넣었는데, 실수를 발견하지 못해 시간이 좀 걸렸다. 로그 찍기 전에 코드 먼저 상세히 봐야겠다.
2. 조건을 꼼꼼하게 읽자, `칸에 적혀있는 수는 0보다 크거나 같고` 문장을 간과해 가장 오른쪽 아래칸만 `0`의 값을 갖는다 판단했다.
3. 로직의 이상한 점을 발견하지 못해, ` 2^63-1`를 의심했는데 역시나였다.

```js
JS 최대 안전 정수 (2^53 – 1)
최소 안전 정수 (-(2^53 - 1))
```

4. BigInt 사용할때 출력은 String()을 이용해야한다.

### 순간 헷갈린 거 재정리

1. 완전 탐색 아닌가?

- 당연히 아니다. `dp[x][y]`를 활용해 이미 계산한 값은 다시 계산하지 않고 사용하고 있다. 또한 visited를 이용해 불필요한 중복 탐색을 방지한다. 완탐이 아니라 `메모이제이션을 활용한 DP 기법`

### 느리다! 더 빠르게 개선한다면?

#### **이전 방식**

1. 오른쪽 아래칸 (`[N-1][N-1]`)에서 시작하여 `map`을 역순으로 탐색
2. 각 칸의 숫자만큼 왼쪽(`←`)과 위쪽(`↑`)으로 이동 가능
3. 이동한 위치가 0이면 `true`로 처리
   - `dp`에 `true` 개수를 기록
   - 이미 방문한 좌표(`visited[x][y] === true`)라면 `dp[x][y]` 값을 누적
4. 0이 아니라면 탐색을 중단하고 continue
5. 탐색이 끝난 후 `dp[0][0]` 값을 출력

#### 개선

- 순방향이 더 빠르다! 역방향으로 하면 출발 지점이 거쳐가지 않는 좌표도 방문해야한다.
- 시작점에 1n으로 두고 출발하면, 시작점이 거쳐야하는 좌표의 값은 >= 1n이 된다. 즉 0n이 아니라면 시작점에서 거쳐야하는 지점이다. => visited 필요 없어진다.
