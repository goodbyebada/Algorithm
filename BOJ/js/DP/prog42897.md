# 📌 문제 설명

[도둑질](https://school.programmers.co.kr/learn/courses/30/lessons/42897)

## 💡 접근 방법

최근에 시험에서 봤던 과수원 문제와 매우 유사하다.
n번째 집을 터냐, 안터냐 두 가지의 선택 중 최대인 값을 고르는 것이다.

`과거의 최선의 선택을 기억하면 오늘 최선의 선택을 만들 수 있다.`

최대인지 판별하기 위해서 이전의 최댓값이 필요하고(매번 계산하면 시간 초과) 때문에 DP를 방법을 사용해야한다.

```js
//i번째 집을 턴다면 i-2번째 집까지의 최댓값 + i번째 집의 돈
// i-1번째 집까지의 최대의 값
Math.max(dp1[i - 2] + money[i], dp1[i - 1]);
```

### 문제

실패한 이유는 원형이라는 점에서 `첫번째 방문하는 집과 마지막 방문하는 집이 인접`해 있기 때문에 경우를 나눠서 계산해야하는데 해당 부분을 고려하지 못했다.

또한, N+2까지 방문하는 헛다리를 짚었는데...
그러면 2번째 집을 중복 방문하는 반례가 생긴다.
dp[i]는 i번째 집을 방문했는지, 방문하지 않았는지 우리는 모른다! 때문에 경우를 분리해 계산을 해야한다.

## ✨ 해결 방법

두 가지의 경우로 나눠야한다.

1. 첫번째 집을 방문하고, 마지막 집을 방문하지 않을때
2. 첫번째 집을 방문하고 , 마지막 집을 방문할 때

두 개의 DP를 이용해서 각각의 최댓값을 구한 후, 두 경우의 max 값을 답으로 return 하면 된다.

### 🚨 초보적이고 오래 걸린 디버깅

### 📌 정리
