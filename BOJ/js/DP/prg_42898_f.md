## 📌 문제 설명

https://school.programmers.co.kr/learn/courses/30/lessons/42898

### 💡 접근 방법

- DP

### 왜 막혔는가/ 왜 틀렸는가

- [x] 구현 실수
- [ ] 아이디어 자체를 못 떠올림
- [x] 유형 파악 실패
- [ ] 유형은 알았는데 적용 방법을 몰랐음
- [ ] 전형적인 테크닉(전처리, DP 점화식 등)을 몰라서 막힘
- [ ] 시간 복잡도 추정/최적화 미흡

#### 이유:

**1. 최단거리만 보고 BFS 판단 금지**:

    - 문제에 `최단 경로의 개수` 라고 적혀있다.
    - 각 좌표에서 최단경로의 개수를 갱신한다.

    ```
       (i,j)에 도달하는 최단경로 개수 = (i-1,j)에 도달하는 최단경로 개수 + (i,j-1)에 도달하는 최단경로 개수
    ```

**2. 순회 방법으로 BFS를 사용했을때의 문제점**:

    - 위 방법을 알고 각 좌표 갱신하고자 했다. BFS로 모든 좌표를 방문하고자 했다. => 지점을 중복 방문하는 문제가 있었다.

    ```js
    // 예시: (2,2) 위치에 도달하는 경우

    // 경로1: (1,1) → (1,2) → (2,2)
    // 경로2: (1,1) → (2,1) → (2,2)

    // BFS에서 (2,2)가 큐에 두 번 들어감!
    q.push([2,2]) // (1,2)에서 추가
    q.push([2,2]) // (2,1)에서 추가

    ```
    - (1,2), (2,1) 둘 다 (2,2)로 갈 수 있음을 반영하기 위함이었지만, (2,2)에서 왼, 오로 가는 로직을 2번 수행하게 된다.

### ✨ 해결 방법

- 핵심 아이디어:

  - `DP`를 이용해야한다. 각 좌표를 반복문을 통해 각각 방문해야한다.
  - dp[i][j]는 (i-1,j)에 도달하는 최단경로 개수 + (i,j-1)에 도달하는 최단경로 개수으로 정의해 왼쪽, 위에서 오는 개수를 계산해야한다.
    - 위 왼쪽 (pull : 다음 -> 현재)
    - 아래 오른쪽 (push : 현재 -> 다음)
  - 둘 다 상관없다! 핵심은 DP 이용이었다.

- 재발 방지 훈련:
- 참고 자료:

### 왜 이 방법이 맞는지 설명하기

### 같은 유형 반복하기

- [ ] 문제1
- [ ] 문제2

### 🚨 초보적이거나 오래 걸린 디버깅

### 📌 정리
