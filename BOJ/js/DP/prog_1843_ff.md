## 📌 문제 설명

https://school.programmers.co.kr/learn/courses/30/lessons/1843

### 💡 접근 방법

- DP

### 왜 막혔는가/ 왜 틀렸는가

- [x] 구현 실수
- [x] 아이디어 자체를 못 떠올림
- [x] 유형 파악 실패
- [ ] 유형은 알았는데 적용 방법을 몰랐음
- [ ] 전형적인 테크닉(전처리, DP 점화식 등)을 몰라서 막힘
- [ ] 시간 복잡도 추정/최적화 미흡

#### 이유:

**1. DFS 로 접근** :
처음 접근을 DFS로 했다. 연산자 기준으로 왼쪽, 오른쪽을 방문해 완전 탐색을 한다! => stackOverflow

    	dfs(3) → dfs(1) 호출
    	dfs(1) → dfs(3) 다시 호출 가능 중복되네...

=> 종료 조건 필요함 + 중복 막기 위해 값을 계산해서 넣는다.

- 길이가 1이라면 -> 최종값이라면 종료한다.

```js
// 새 토큰 배열 생성
const nextTokens = [
  ...tokens.slice(0, i - 1),
  String(calc),
  ...tokens.slice(i + 2),
];
```

=> 대략적으로 계산해도 시간초과 O(2^N) => 10 ^ (201 \* 0.3~)
(정확히는 시간복잡도는 O(4^n)이라는데 이해 못함 ㅋ)

### ✨ 해결 방법

- 핵심 아이디어: **DP**

  사용하는 이유 : 같은 계산이 반복된다.
  Ex) 1 - 2 + 3 - 4 + 5 => - , + 에서 연산에서 (4 + 5) 중복 계산된다.

  핵심 내용: 구간을 이용해 최댓값을 정해두면 다시 계산하지 않고 사용하면 됨

  **주의 내용**: +, - 일때 다르다.
  => [0-i번째의 최댓값]+ [i+1-j번째의 최댓값], [0-i번째의 최댓값]-[i+1-j번째의 최솟값]

  - 따라서 아래와 같이 최댓값을 관리하는 maxDP 배열과 minDP배열이 필요하다.

    - 항상 최댓값을 저장하는 maxDP와 -를 위해 필요한 minDP는 무즈껀 최솟값을 관리해야한다 각각.

    ```
    if(연산자 == +)
    dpMax = max(dpMax, dpMax[][] + dpMax[][])
    dpMin = min(dpMin, dpMin[][] + dpMin[][]) // 무조건 min의 값을 가지고 있어야한다.

     if(연산자 == -)
    dpMax = max(dpMax, dpMax[][] -  dpMin[][])
    dpMin = min(dpMin, dpMin[][] -  dpMax[][]) // min이 되어야하니까 최소- 최대를 계산한다.

    ```

    - 처음에 + 일때는 Max를, -일때는 min으로 분리해서 계산한다고 생각했다. 근데 그러면 빵꾸난다~

- 재발 방지 훈련:
- 참고 자료:

### 왜 이 방법이 맞는지 설명하기

### 같은 유형 반복하기

- [ ] 문제1
- [ ] 문제2

### 🚨 초보적이거나 오래 걸린 디버깅

1. max, min 초기화 => 0으로 해서 틀렸음

   - max는 무조건 -Infinity min은 Infinity 초기화 습관 들이자.

2. dp [i][j]의 의미에 맞춰서 return 출력하기

   - 순간 [N-1][N-1]에 누적되는 줄 , 하지만 i j 의미가 i~j 사이의 최댓값이었음 => 틀림

3. 배열 초기화
   - 피연산자의 개수만큼 초기화해야함

### 📌 정리

**잘 모르겠음**

- dp -> bottomup, topdown의 차이를 잘모르겠다. 언제써야하는지 예시 좀

  - bottomUp

    - 계산 순서가 명확할 때
    - 모든 하위 문제를 다 써야 할 때
    - 메모리 최적화가 쉬울 때

  - topdown

    - 재귀적 정의가 자연스러울 때
    - 일부 하위 문제만 필요할 때
    - 복잡한 조건문이 많을 때

- 메모제이션 + dfs vs dp 의 차이? 마찬가지로 예시와 함께 설명해줘

  - 메모제이션 + dfs: 모든 경우 다 계산할 필요없다.

    > 문제: 특정 금액을 만드는 최소 동전 개수동전: [1, 3, 4], 목표: 6 → 답: 2개 (3+3)
    > "if-else 분기가 복잡함" - 조건에 따라 다른 계산

  - dp : 다 해야한다. 계산 순서가 뚜렷하다.
