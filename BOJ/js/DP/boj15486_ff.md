## 📌 문제 설명

https://www.acmicpc.net/problem/15486

### 💡 접근 방법

- dp 이용

### 왜 막혔는가/ 왜 틀렸는가

- [ ] 구현 실수
- [ ] 아이디어 자체를 못 떠올림
- [ ] 유형 파악 실패
- [ ] 유형은 알았는데 적용 방법을 몰랐음
- [ ] 전형적인 테크닉(전처리, DP 점화식 등)을 몰라서 막힘
- [ ] 시간 복잡도 추정/최적화 미흡

- [x] 유형은 알았는데 적용방법이 틀림

#### 푼 방식

1. dp[i]는 i일까지 일한 최댓값
2. i 0 ~n까지 순회한다.

   - 1. dp[i] + w , dp[i+t] 의 최댓값을 비교해 i+t의 dp 값을 업데이트한다.
   - 2. dp[i] === 0 이라면, dp[i-1]로 업데이트한다. => dp[i]의 일이 없다면, i-1날까지 일한 금액이 최댓값

3. dp[i] 확장 전에, dp[i+t]를 갱신함

   - 위와 같은 로직으로 한다면, dp[i]가 i까지 일한 최댓값이 아니다.
   - 따라서 dp[i+t]의 값을 업데이트할때 , dp[i]+w 의 의미가 i의 일까지 일한 최댓값+ w가 아니라 초깃값인 0+w가 된다. => 놓친 부분 📌

### ✨ 해결 방법

- 핵심 아이디어: i는 i일까지 일한 최대 값
- 재발 방지 훈련:
  - dp 점화식 설계시 사용하는 값이 이미 확정됐나? 확인할 것
- 참고 자료:

### 왜 이 방법이 맞는지 설명하기

### 같은 유형 반복하기

- [ ] 문제1
- [ ] 문제2

### 🚨 초보적이고 오래 걸린 디버깅

### 📌 정리
