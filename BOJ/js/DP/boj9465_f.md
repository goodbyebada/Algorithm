## 📌 문제 설명

https://www.acmicpc.net/problem/9465

### 💡 접근 방법

### 왜 막혔는가/ 왜 틀렸는가

- [ ] 구현 실수
- [x] 아이디어 자체를 못 떠올림
- [x] 유형 파악 실패
- [ ] 유형은 알았는데 적용 방법을 몰랐음
- [ ] 전형적인 테크닉(전처리, DP 점화식 등)을 몰라서 막힘
- [ ] 시간 복잡도 추정/최적화 미흡

### ✨ 해결 방법

- 핵심 아이디어: 최댓값 도출 dp임을 확인하고, 반복되는 패턴을 찾기

- 완전 탐색하면 다음 선택하는 경우의 수 2^(10^6) => 시간 초과 + 중복됨(50-> 50-> 100, 100입장에서 선택할때 , 100-> 50 ->50)
- 중복되는 문제, 이전열까지 떼어낸 스티커들의 최대 점수를 바탕으로 최적의 선택 가능 => DP를 선택해야한다.

- 스티커를 떼어내다 보면, 중간열들은 0행, 1행 모두 안 떼어지는 경우가 있다. 하지만 어떤 경로든 마지막 N-1열은 무조건 하나는 떼어진다.
  => 따라서 dp[0][n-1] 과 dp[1][n-1]을 비교해 최댓값을 return 하면 된다.

### 왜 이 방법이 맞는지 설명하기

- 1. 최대합 문제 -> 그리디는 최적해를 보장하지 못하므로 제외
- 2. 완탐은 시간 초과로 불가능
- 3. dp
  - i번째 열을 선택하면, i-1열 행은 자동으로 배제
  - i번째 선택 => i-1, i-2 상태에 의존한다 => 현재 선택 과거 선택 결과에 따라 제약 받는다 dp 특징

### 같은 유형 반복하기

- [ ] 문제1
- [ ] 문제2

### 🚨 초보적이고 오래 걸린 디버깅

- 처음 하드 코딩으로, n==1 일 경우 행을 둘 다 0으로 둬서 틀렸다.

### 📌 정리
