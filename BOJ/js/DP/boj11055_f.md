# 📌 문제 설명

[가장 큰 증가하는 부분 수열](https://www.acmicpc.net/problem/11055)

## 💡 접근 방법

최댓값의 정보를 저장해 사용하기 위해,DP를 이용하는 문제라고 생각했다.

### 문제

0. 같은 DP 유형이지만 과수원 문제와는 다른 문제이다. 현재 i번째 숫자를 뽑을지, 말지를 보는 것이 아니라 i번째 수가 수열의 마지막 원소임일때 최댓값을 갱신해야 푸는 문제이다.

1. 이전의 값이 dp[j] < dp[i]라면 (j까지 선택했을때 최댓값+ i를 선택했을때 값)을 더해서 갱신하면 된다고 생각했다.

   `가장 가깝고 && dp[j] < dp[i]`를 만족하는 값이 dp[i]가 이을 수 있는(증가하는 수열) 최대값이라고 생각함

```js
for (let j = i - 1; j >= 0; j--) {
  // 작은 값이 있다면 그 최댓값을 비교
  // 뽑을지 안 뽑을지
  if (A[i] > A[j]) {
    dp[i] = dp[j] + A[i];
    //   dp[i] += dp[j];
    //   누적된 값을 차례 차례 더하는 것이기 때문에 틀린 답
    break;
  }
}
```

하지만 `i번째 이전에 오는 증가하는 수열이 여러개`일 수 있고, 값이 랜덤이기 때문에 틀린 생각이다!

```js
//반례
1 3 2 5

1 4 3 Math.max(4+5, 3+5)

```

## ✨ 해결 방법

때문에 i보다 작은 인덱스들을 모두 순회하며, dp[j]중 가질 수 있는 `가장 최대의 값을` 찾은 후 A[i](원본 값)을 더해 갱신해야한다.

### 🚨 초보적이고 오래 걸린 디버깅

### 📌 정리
