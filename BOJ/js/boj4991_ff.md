## 📌 문제 설명

[로봇 청소기](https://www.acmicpc.net/problem/4991)

### 💡 접근 방법

### 왜 막혔는가

- 자료구조 및 구현 방법을 아예 모르겠다. 😿

최단거리이기 떄문에 BFS를 이용해 풀면 될 것 같다.
하지만 더러운 지점 방문 이후,또 다른 더러운 지점으로 이동해야하는데 , 그럼 왔던 거리를 다시 중복 방문해서 와야한다.
-> 그럼 BFS를 사용 못한다. 아님 발견하는 순간 visited는 버리거나
-> 출발과 목적을 reverse 시켜서 복귀한다..?

처음에는 로봇의 위치를 중앙에 두고, 각 (중간 지점 ~ 더러운 지점까지의 거리 )\*2를 해서 구하면 된다 생각했다.
하지만 로봇의 위치에 따라 (정중앙에서 ~ 더러운 지점까지의 거리)가 최솟값이 아닐 수 있다. 또한 행열의 길이가 홀수가 아니라면 정중앙을 찝기도 애매하다.

### ✨ 해결 방법

1. 로봇 청소기(o), 더러운 곳(\*)의 좌표를 찾는다.
2. 로봇 청소기와 각 더러운 곳 사이의 거리, 더러운 곳과 더러운 곳과의 사이의 거리를 계산한다.
3. 순열을 통해 가능한 모든 경로를 계산한다. 최소 거리의 길이를 구한다.

- `주의`: 그리디가 아닌 완전 탐색을 해야한다. 반례) 같은 길이의 다른 두 개의 경로

### 문제

1. 순열을 계산할 때 메모리에 저장했을 시 `메모리 초과` 문제 발생했다.

   - 10! \* (10 \* 8byte) 라서 안됨
     -> 순열을 하나씩 생성하면서 쓰고 버리는 방식 써야함

2. 로봇 청소기 벽들로 둘려쌓여있어서 접근 못하는 경우도 고려할 것

### 🚨 초보적이고 오래 걸린 디버깅

- BFS가 왜 제대로 돌지 않는가
  -> row(행)의 길이는 W(넓이), col(열)의 길이는 H(높이)

  N\*N 배열에 익숙해져서 행 열의 길이를 따로 줬을때 배열 만들기, 범위 체크 조심하자

### 📌 정리
