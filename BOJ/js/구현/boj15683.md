# 📌 문제 설명

https://www.acmicpc.net/problem/15683

## ✨ 해결 방법

- DFS 방법을 이용해 모든 경우의 케이스를 계산한다.

1. cctv를 찾는다.
2. 찾은 cctv 리스트를 통해 모든 경우의 케이스를 계산한다. DFS를 이용해 완전탐색한다.

   - 각 cctv는 90도로 이동이 가능해 모두 4가지 케이스를 가지고 있다.
   - 번호에 따라 cctv의 각도가 달라짐을 고려해야한다.

3.DFS 구현

- 재귀 탈출 조건 : cctv index === cctv.length

- cctv list에 있는 cctv를 방문한다. => index를 이용한다.
- 몇 번째 cctv임을 계산한다.
- 각 cctv는 `4개의 각도`일 때를 봐야한다.
  => 각 `각도`일 때 cctv의 `감시 가능 영역`을 업데이트 하고 다음 재귀(index+1)로 넘어간다.

5. `checkOneDirection` => 각 `각도`에서의 map을 업데이트 하는 함수이다.

- 몇 번째 cctv이냐에 따라 감시 가능 영역이 달라진다.
- 몇 번째 cctv인지 알아내고 , 감시 가능 영역 방향을 반복문으로 계산한다.

6. 사각지대인 0인 좌표들을 개수를 더해 영역을 계산한다.
   -> 최소값을 갱신한다.

### 틀렸던 점

1.cctv의 `각도`가 90도로 이동이 되기 때문에 4개의 방향을 방문해야한다.
-> 하지만 몇 번 cctv이냐에 따라 `감시 가능 영역`이 매번 달라진다
=> 🚨 구현하지 못했다.

`각도의 방향` 상 우 하 좌(시계방향)를 숫자 0,1,2,3 로 표시하고,
cctv의 각도가 90도로 이동함에 따라 (시계방향) `감시 가능 영역`을 대괄호로 구분하자면
1번 cctv : [0] [1] [2] [3] 방문 => 방향에 따라 보면 된다.
2번 cctv: [0,2] [1,3] [2,0(4%4)] [3,1(5%4)] 을 봐야한다.
3번 cctv: [0,1] [1,2] [3,0(4%4)] [0(4%4),1(5%4)] 을 봐야한다.
4번 cctv: [0,1,2] [1,2,3] [2,3,4] [3,0,1] 을 봐야한다.
5번 cctv: [0,1,2,3] [0,1,2,3] [0,1,2,3] [0,1,2,3] 을 봐야한다.

이를 통해 한 `각도`에 `감시 가능 영역`의 방향이 1개, 2개, 2개, 3개, 4개임을 알 수 있다.
또한 `방향`을 알 수 있기에 `감시 가능 영역` 좌표를 계산할 수 있다.

```
const addedDirectons = [0, [0], [0, 2], [0, 1], [0, 1, 2], [0, 1, 2, 3]];
```

2. 한 DFS 당, 4가지의 방향을 고려하는 반복문에서 배열 초기화
   => `각도`에 따라 `감시 가능 영역`의 방향이 다르다.
   => 채워져야하는 부분이 다르다.
   => 따라서 다음`각도`로 넘어가는 for문에서 배열 초기화를 시켜줘야한다.

### 📌 정리
