# 📌 문제 설명

[문제 링크](https://www.acmicpc.net/problem/13460)

## 💡 접근 방법

- 구현 & BFS

### 문제

1. `R과 B가 붙어있을때 이동한 위치 계산을 어떻게 할 것인가?`을 구현하는 것이 어려웠다.
   결국 구현하지 못해 답안을 보고 문제를 해결했다.

   => `겹칠 때만을 주의하면 된다`

   - 같은 방향으로 움직인 후, 위치가 같은지 검사한다.

   - 더 많이 움직인 좌표가 해당 방향에서 더 뒤에 있었기 때문에 -dir을 해준다면 겹치지 않을 수 있다.

2. visited 확인하는 방법, 처음에 순회로 구현했다 시간초과가 일어났다. 시간 초과가 일어나지 않고 빠르게 확인하는 두 가지 방법이 있다.

   a. visited[rx][ry][bx][by] 4차원 배열로 확인

   ```js
   //단점 초기화가 빡세다
   //장점 제일 빠르다
   let visited = Array.from({ length: N }, () =>
   Array.from({ length: M }, () =>
   Array.from({ length: N }, () => Array(M).fill(false))
   )
   ```

   b. set 이용하기

   - 위치를 문자열로 이어 set에 넣으면 쉽게 할 수 있다.

   ```js
   const key = `${nrx},${nry},${nbx},${nby}`;
   if (visited.has(key)) continue;
   visited.add(key);
   ```

## ✨ 해결 방법

1. 최단 거리를 구하기 위해 BFS로 접근한다.
2. 현재 좌표에서 상하좌우로 움직인 후, 큐에 넣는다.

   - Q.front()를 꺼낸다.
   - count >= 10이라면 실패이기에 "break"

3. front에 있는 좌표 redball, blueball을 움직인다.

   - 이 때 "#" 되기 전 혹은 "O"일때까지 움직여야한다.
   - redball, blueball 모두 같은 방법으로 움직인다.

4. 움직인 후의 공이 "O"에 빠졌는지 검사한다.

   - 이때 blueball의 위치가 "O"이라면 실패이기 때문에 큐에 넣지 않는다. 아예 방문하지 않는다!
     => 좌표 조정하기 전에 검사한다. 어차피 blueball이 "O"를 만나게 되면 실패이기 때문이다.
   - 다음으로 redball, blueball의 위치가 겹친다면 각 공의 이동거리를 비교해 겹치지 않게 좌표를 조정한다.
   - 이후 redball === "O"인지 확인한다. 최단 거리로 성공했기 때문에 count+1을 return

5. 앞에 있는 경우가 아니라면 계속 움직인다.

   - 이동한 redBall, blueBall, count의 정보를 큐에 넣는다.

6. Q.empty()라면 answer 의 초기화된 값 -1을 출력한다.

### 📌 정리

1. 여러개의 좌표가 나온다면, 하나의 객체로 만들어 가지고 다니자.
   처음에 [redball, blueBall, count] 이렇게 가지고 다녔는데, 해체 했다 다시 합치고, 그럴때마다 네이밍을 바꿔야하고 더욱 헷갈렸다.

2. `if (count >= 10) break;` 조건 써놓고 빼먹었다. 다 풀고 써놓은 조건대로 구현이 되었는지 다시 한번 확인하자

3. `빨간 공이 들어간 다음 , 파란 공이 들어가도 실패이다` 해당 조건을 놓쳤었다.

   => 의심..의심..애매한 케이스를 생각하고 예제를 유심히 살펴보자
