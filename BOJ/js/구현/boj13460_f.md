# 📌 문제 설명

[문제 링크](https://www.acmicpc.net/problem/13460)

## 💡 접근 방법

- 구현 & BFS

### 문제

1. R과 B가 붙어있을때 이동한 위치 계산을 어떻게 할 것인가?

- 해결하지 못해 답지를 봐버렸다 😿

- 처음에 R기준으로 상하좌우를 매번 계산하고, R의 상하좌우 중 B가 있다면 해당 방향으로 이동할때 R이 #을 만났을때 그 자리에 B를 놓고 그 방향 보다 덜 가서 R을 놓는 방법을 하려고 했다.

  ex) B가 R의 상에 위치해있다면, R이 상으로 움직일때 위치를 고려한다. R === "O" || R+dir === "#"이라면,,,현재 위치를 B , R은 [0,-1]인 좌표를 준다.

  하지만 고려해야할 케이스가 많아 구현에 실패했다.

  => 더 정형화 된 방법이 있다. `겹칠 때만을 주의하면 된다`

  따라서 같은 방향으로 움직인 후, 위치가 같은지 검사한다.
  더 많이 움직인 좌표가 해당 방향에서 더 뒤에 있었기 때문에 -dir을 해준다면 겹치지 않을 수 있다.

2. visited 방문 시,

- BFS 특성 :
  최단 거리를 위해 앞만 보고 달린다! 이미 방문한 지점은 다시 방문하지 말아야한다.

  이를 위해 visited 배열이 필요한데 처음에 visited 배열의 모든 원소들을 검사하는 방법을 썼다.
  => `시간초과`

  ```js
        //아래는 시간 초과 남
        let alreadyVisited = false;

        for (const [vBalls, vCnt] of visited) {
          if (count + 1 === vCnt && vBalls.isSamePos(nrx, nry, nbx, nby)){
            alreadyVisited = true;
            break;
          }
        }
        if (alreadyVisited) continue;
  ```

1. visited[rx][ry][bx][by] 4차원 배열로 확인

   ```js
   //단점 초기화가 빡세다
   //장점 제일 빠르다
   let visited = Array.from({ length: N }, () =>
   Array.from({ length: M }, () =>
     Array.from({ length: N }, () => Array(M).fill(false))
   )
   ```

2. set 이용하기

   - 위치를 문자열로 이어 set에 넣으면 쉽게 할 수 있다.

   ```js
     const key = `${nrx},${nry},${nbx},${nby}`;
     if (visited.has(key)) continue;
     visited.add(key);
   ```

## ✨ 해결 방법

1. 최단 거리를 구하기 위해 BFS로 접근한다.
2. 현재 좌표에서 상하좌우로 움직인 후, 큐에 넣는다.

   - Q.front()를 꺼낸다.
   - count >= 10이라면 실패이기에 "break"

3. front에 있는 좌표 redball, blueball을 움직인다.

   - 이 때 "#" 되기 전 혹은 "O"일때까지 움직여야한다.
   - redball, blueball 모두 같은 방법으로 움직인다.

4. 움직인 후의 공이 "O"에 빠졌는지 검사한다.

   - 이때 blueball의 위치가 "O"이라면 실패이기 때문에 큐에 넣지 않는다. 아예 방문하지 않는다!
     => 좌표 조정하기 전에 검사한다. 어차피 blueball이 "O"를 만나게 되면 실패이기 때문이다.
   - 다음으로 redball, blueball의 위치가 겹친다면 각 공의 이동거리를 비교해 겹치지 않게 좌표를 조정한다.
   - 이후 redball === "O"인지 확인한다. 최단 거리로 성공했기 때문에 count+1을 return

5. 앞에 있는 경우가 아니라면 계속 움직인다.

   - 이동한 redBall, blueBall, count의 정보를 큐에 넣는다.

6. Q.empty()라면 answer 의 초기화된 값 -1을 출력한다.

### 📌 정리

1. 여러개의 좌표가 나온다면, 하나의 객체로 만들어 가지고 다니자.
   처음에 [redball, blueBall, count] 이렇게 가지고 다녔는데, 해체 했다 다시 합치고, 그럴때마다 네이밍을 바꿔야하고 더욱 헷갈렸다.

2. `if (count >= 10) break;` 조건 써놓고 빼먹었다. 다 풀고 써놓은 조건대로 구현이 되었는지 다시 한번 확인하자

3. `빨간 공이 들어간 다음 , 파란 공이 들어가도 실패이다` 해당 조건을 놓쳤었다.

   => 의심..의심..애매한 케이스를 생각하고 예제를 유심히 살펴보자
