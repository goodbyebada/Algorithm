## 📌 문제 설명

골드 5
[치킨 배달](https://www.acmicpc.net/problem/15686)

### 💡 접근 방법

치킨 거리:집과 가장 가까운 치킨집의 사이

각 집마다의 치킨 거리를 계산하고 => 완탐
어떤 치킨 집이 사라지냐에 따라 각 집의 치킨 거리가 변경된다. 때문에 모든 치킨 집과의 거리가 있어야한다.

1. 치킨집의 위치, 각 집의 위치를 찾는다.
   집 (인덱스 - 위치)
   치킨 집 (인덱스 - 위치)
2. `각 치킨 집 - 집` 사이의 거리를 저장한다.
3. M개의 치킨 집을 고른다. (조합)
   1. 각 집의 치킨 거리를 구한다.
   2. 모든 각 집의 치킨 거리의 합을 구한다.
   3. 가장 작은 값(목표) 이라면 갱신한다.

### 왜 막혔는가/ 왜 틀렸는가

1. 처음에 치킨집을 앞에서 부터 순서대로 M개를 뽑으면 된다 착각했다. 👹
2. `backTracking(depth, used, shops)`에서 shops를 넘길때,

   [...shops, i] => n단계의 치킨 집 원소들, 현재 추가한 치킨 집 원소한 `새로운 배열`을 n+1 단계로 넘겨야한다.
   그래야, n+1 단계를 끝내고 왔을 때, n단계에서 n단계까지의 shops들로 유지된다.
   === 배열이 참조로 전달되기 때문에 원본이 오염!
   하지만 `shops.push(i);`를 n단계에서 n+1단계 shops들을 가져 틀렸다. 👹

### ✨ 해결 방법

### 🚨 초보적이고 오래 걸린 디버깅

### 📌 정리

- 조합 문제는 항상 복사를 염두에 두고 재귀에서 관리하자.

- 스택을 이용한 조합 `(combination)`

  1.현재까지 선택한 요소들을 스택(혹은 배열)에 저장한다.

  2.depth === M이 되면 조합 하나를 완성한 것.

  3.다음 요소 선택 시 현재 인덱스 이후부터 반복한다. (중복 방지)

  4.함수형 복사 없이, push/pop으로 상태를 복원한다.

  ```js
  // 📌 stack을 이용한 조합
  for (let i = start; i < chickenHouse.length; i++) {
    store.push(chickenHouse[i]); // 1. 스택에 추가
    bt(depth + 1, i + 1); // 2. 다음 인덱스부터 재귀
    store.pop(); // 3. 돌아와서 복구
  }
  ```

- 처음에 거리를 다 저장해두고 풀었다. 하지만 개수가 적어서 바로 계산하는 것이 오히려 더 비용이 적다.
  180ms > 164ms
