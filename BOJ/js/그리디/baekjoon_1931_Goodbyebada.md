# 📌 문제 설명

## 💡 접근 방법

## ✨ 해결 방법

- 항상 **최적의 해**를 도출하려면, 즉 **많은 회의를 넣으려면 회의 시간을 최대한 많이 확보**해야 한다.
- 따라서, **빨리 끝나는 회의를 우선적으로 선택**해야 한다.
- 이 말은 곧, **회의 종료 시간을 기준으로 오름차순 정렬**해서 가장 빨리 끝나는 회의부터 고려하겠다는 뜻이다.
- 그 후, **회의의 시작 시간이 이전 회의의 종료 시간 이상인지** 확인하면서 회의를 선택하면 된다.

```js
const sorted = data.sort((a, b) => a[1] - b[1]);
```

## ⛑️ 주의

처음에는 회의 종료 시간만을 기준으로 정렬했는데, 이 방식으로는 **다음과 같은 반례**가 발생할 수 있다.

```
입력
3
3 3
3 3
1 3

정렬 결과
3 3
3 3
1 3

답 : 3
```

위 예시에서 `3 3` 회의 2개가 먼저 선택되면, 그 이후에는 `1 3` 회의를 선택할 수 없게 된다.
하지만 `1 3` → `3 3` → `3 3` 순으로 고르면 총 3개의 회의를 선택할 수 있다.

따라서 **종료 시간이 같을 경우 시작 시간을 기준으로도 정렬**해줘야 한다.

## 📌 정리

- **종료 시간 오름차순**, 그리고 **종료 시간이 같으면 시작 시간 오름차순**으로 정렬해야 한다.
- 항상 **가능한 한 빨리 끝나는 회의**를 선택해야 최대한 많은 회의를 넣을 수 있다.
