# 📌 문제 설명

## 💡 접근 방법

- 풀이를 보고 재작성했다.

### 문제

## ✨ 해결 방법

최단거리이니 BFS를 활용해야했음을 파악했다.
하지만, 언제 벽을 부숴야하는지에 대해 어떻게 판단해야하느냐가 관건이었다.

시작점 -> x-> 도착점

시작점 -> x 오면서 벽을 부수고 오지 않을 수도 부수고 올 수 있다.

1. 만약 부수고 온다면, 도착점 근처에 벽이 있을때 벽을 방문할 수 없는 경우가 있다.
2. 부수고 오지 않았는데, 도착점 근처에 벽이 없어 이전에 벽을 부술 수 있다.

때문에 모든 경우를 다 탐색해야한다!

1. x 지점까지 벽을 부수고 도착점까지 출발하는 경우
2. x 지점에서 도착점까지 벽을 부수는 경우

- BFS를 통해 최단 거리를 탐색한다.
- 벽을 부쉈는지 판단하기 위해 이전의 벽 파괴 유무를 알아야한다. 큐에 함께 넣어야한다.

갈 수 있는 경우는 두 가지 경우이다.

- 벽이 있고 & 벽을 파괴 가능
- 벽이 아닌 경우 & 방문하지 않은 경우 ( 거리가 >= 0 이상이라면 방문했다는 것.)

//[0,0,1]의 처리에 대해서 헷갈렸다.
0으로 초기화 하고 시작할 것인지, 아님 -1을로 미방문 상태로 둘 것인가

-> 둘 다 상관없다!
어차피 [0,0,0] -> [0,1,?], [1,0,?] 방문이다.
[0,0,1](벽 부술 수 없는 상태)에서 방문하려면 [0,1,0] [1,0,0]만 방문이 가능하다.
만약 둘 다 [0,1,0] [1,0,0] 상태는 이미 이전에 방문했기 때문에 거리가 새로 갱신될 일 없다.

### 📌 정리

1. x와 y를 착각해서 엄청난 시간을 디버깅에 쏟았다.. 처음에 로직이 문제인 줄 알았는데, x와 y를 거꾸로 놔서 발생한 이슈였다. 배열은 x를 행, y를 열로 놓고, 로직은 거꾸로 짰다.
   -> 처음에는 방문해야할 좌표를 방문하지 않고 알아서 끝내서 로직 문제인 줄 알았다.
   -> 디버깅 하는 중에 undefined가 발생해서 그제야 알았다.
   -> 로직이 문제가 없어 보인다면, 좌표를 의심해보자!
